# Runtimes

`WorkflowRuntime` is responsible for the following tasks:

1. Managing workflow state
2. Persisting events
3. Recovering state from events
4. Waking up the workflow at the right moments

Each runtime is created per workflow type, and its creation usually involves implementation-specific elements.
`WorkflowRuntime` interface allows creating a `WorkflowInstance` based on id and input.

```scala 3
trait WorkflowRuntime[F[_], Ctx <: WorkflowContext, WorkflowId, Input] {

  def createInstance(id: WorkflowId, input: Input): F[WorkflowInstance[F, WCState[Ctx]]]

}

```

## Available Runtimes

Below is an overview of the available runtimes, with their strengths and limitations:

<table>
    <thead>
    <tr>
        <th>Runtime</th>
        <th>Description</th>
        <th>Good For</th>
        <th>Bad For</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td><a href="pekko"><code>PekkoRuntime</code></a></td>
        <td>Uses Pekko Persistance and Cluster Sharding to manage the state and distribution of workload.</td>
        <td>
            <ul>
                <li>Scalability</li>
                <li>Sophisticated requirements</li>
            </ul>
        </td>
        <td>
            <ul>
                <li>Small-scale setups</li>
                <li>Low complexity use-cases</li>
            </ul>
        </td>
    </tr>
    <tr>
        <td><a href="database"><code>DatabaseRuntime</code></a></td>
        <td>Relies on database storage and locking mechanisms, without any in-memory state management.</td>
        <td>
            <ul>
                <li>Simplicity</li>
                <li>Low memory footprint</li>
            </ul>
        </td>
        <td>
            <ul>
                <li>High throughput</li>
                <li>Frequent state access</li>
            </ul>
        </td>
    </tr>
    <tr>
        <td><a href="in-memory"><code>InMemoryRuntime</code></a></td>
        <td>Based on Cats Effect; keeps state in memory without persistence.</td>
        <td>
            <ul>
                <li>Fast execution</li>
                <li>Ephemeral workflows</li>
            </ul>
        </td>
        <td>
            <ul>
                <li>Long-running workflows</li>
                <li>State durability</li>
            </ul>
        </td>
    </tr>
    <tr>
        <td><a href="in-memory"><code>InMemorySyncRuntime</code></a></td>
        <td>Vanilla Scala implementation, not thread-safe and lacks persistence.</td>
        <td>
            <ul>
                <li>Simple workflows</li>
                <li>Experimentation</li>
                <li>Single-threaded scenarios</li>
                <li>Testing</li>
            </ul>
        </td>
        <td>
            <ul>
                <li>Production use cases</li>
            </ul>
        </td>
    </tr>
    </tbody>
</table>

## WorkflowEngine

Each `WorkflowRuntime` is parameterized by a `WorkflowInstanceEngine`,
a component that proxies all interactions between the instance and its state, allowing for plugging-in custom behaviours.

Below is an example of building an engine.

```scala file=./main/scala/workflows4s/example/docs/EngineExample.scala start=doc_start end=doc_end
```

### KnockerUpper

`KnockerUpper` is a component responsible for waking up the workflow when needed, e.g., after timer has expired or retry is due.
See [Wake-Ups](./04-knocker-uppers.mdx) for additional details.

### WorkflowRegistry

`WorkflowRegistry` is a component responsible for tracking the execution status of workflow instances.
See [Collecting Instances](./05-workflow-registry.mdx) for additional details.
